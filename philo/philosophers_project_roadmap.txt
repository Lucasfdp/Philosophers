
42 Philosophers Project â€“ Roadmap & Conceptual Flow
===================================================

ğŸ§© Key Components
-----------------
You'll ultimately need to write:
1. Main program: Parses args, initializes everything.
2. Philosopher struct: Represents each philosopher.
3. Forks: Shared mutexes between philosophers.
4. Thread routine: Behavior of each philosopher.
5. Death checker: Watches for starving philosophers.
6. Logger: Synchronized printing.
7. Cleanup: Gracefully destroy all mutexes/threads.



ğŸ Step-by-Step Flow
--------------------

ğŸ”¹ 1. Understand the Problem (Day 0)
- Read about the Dining Philosophers Problem:
  - What is deadlock?
  - Why is mutual exclusion needed?
  - Why is starvation possible?
- Understand the goal: simulate philosophers eating without crashing, deadlocking, or letting anyone die unexpectedly.

New Concepts:
- Deadlock, Starvation, Race conditions, Mutual exclusion (mutex)

ğŸ”¹ 2. Parse and Validate Input (Day 1)
- Write your main.c and parse arguments
- Validate ranges (positive ints only)
- Store in a global config struct

ğŸ”¹ 3. Define Core Structs (Day 2)
Create `philo.h`:

ğŸ”¹ 4. Initialize Forks and Philosophers (Day 3)
- Allocate array of t_philo
- Create array of pthread_mutex_t forks
- Assign left and right forks in circular fashion

ğŸ”¹ 5. Create Philosopher Threads (Day 4)
Each thread runs:

void *philosopher_routine(void *arg);

Loop: Take forks â†’ Eat â†’ Release forks â†’ Sleep â†’ Think

New Concepts:
- Threads: pthread_create, pthread_join
- usleep(), gettimeofday()

ğŸ”¹ 6. Time Management (Day 5)
Use gettimeofday() or clock_gettime()
- Track when philosophers eat
- Check if someone has died
- Print timestamps

Write a get_time_in_ms() function.

ğŸ”¹ 7. Logging with Mutex (Day 5-6)
- Use print_lock mutex for logging
- Format: timestamp + philosopher ID + action

ğŸ”¹ 8. Monitor for Death (Day 6)
- Separate monitor thread or main polling loop
- If time since last meal > time_to_die â†’ mark death

New Concepts:
- Shared state monitoring with mutex

ğŸ”¹ 9. Optional Eating Count (Day 7)
If 5th arg is given:
- Terminate when all have eaten `n` times

ğŸ”¹ 10. Cleanup (Day 8)
- Free all memory
- Destroy all mutexes
- Join all threads




ğŸ“˜ Concepts to Master
---------------------
| Concept         | Description                                  |
|-----------------|----------------------------------------------|
| Threads         | pthread_create, pthread_join, detach         |
| Mutexes         | Locking forks, printing, meal checks         |
| Race conditions | Prevented with mutexes or atomic values      |
| Deadlock        | Avoid circular waits (odd/even fork strategy)|
| Starvation      | Ensure fair scheduling and exit condition    |
| Timing          | Accurate timestamps with gettimeofday()      |
| Graceful exit   | Clean up all resources on exit               |

ğŸ“ Suggested File Structure
---------------------------
philosophers/
â”œâ”€â”€ Makefile
â”œâ”€â”€ main.c
â”œâ”€â”€ init.c
â”œâ”€â”€ routine.c
â”œâ”€â”€ monitor.c
â”œâ”€â”€ time_utils.c
â”œâ”€â”€ utils.c
â”œâ”€â”€ philo.h



ğŸš¦ Starter TODO Checklist
--------------------------
âœ… Parse args & validate  
âœ… Define t_config and t_philo  
âœ… Init forks & philosopher structs  
âœ… Thread creation + routine  
âœ… Accurate sleeping & time checking  
âœ… Death monitor  
âœ… Mutex-protected printing  
âœ… Graceful exit & cleanup



Dining Philosophers Problem â€“ Full Conceptual Breakdown
ğŸ What is the Dining Philosophers Problem?
Originally proposed by Edsger Dijkstra, this classic concurrency problem models 
a situation where a group of philosophers must alternate between thinking and 
eating, but they must share limited resources (forks) to eat â€” leading to potential 
deadlock or starvation.

ğŸ­ Scenario
N philosophers sit at a round table.

Between each two philosophers is one fork â€” so N forks total.

A philosopher must pick up two forks (left and right) to eat.

Philosophers must avoid:

Deadlock: Everyone grabs one fork and waits forever.

Starvation: A philosopher never gets to eat.

ğŸ§© Core Simulation Elements (Mapped to Code)
Concept	Description	Code Element
Philosopher	A thread that eats/thinks/sleeps	pthread_t, t_philo
Fork	Shared resource (mutex)	pthread_mutex_t
Time to die	Max time without eating	Timestamps
Time to eat/sleep	Duration of actions	usleep, timers
Meal count	Optional: exit after N meals	meals_eaten counter




âš ï¸ Problems You Must Prevent
ğŸ” Deadlock
Problem: Each philosopher picks up one fork and waits â†’ no one can eat.

Solutions:

Odd philosophers pick left fork first, even ones right first.

Use a semaphore to allow only N - 1 philosophers to pick up forks at a time.

ğŸ˜µ Starvation
Problem: One philosopher never gets to eat.

Solutions:

Monitor last meal time.

Use a monitor thread.

Use num_must_eat condition to enforce fairness.

ğŸ”§ Resources and Tools Used
1. Threads (pthread)
Each philosopher is a thread:
pthread_create(&philo[i].thread, NULL, &routine, &philo[i]);

2. Mutexes (pthread_mutex)
Each fork is a mutex:
pthread_mutex_lock(philo->left_fork);
pthread_mutex_lock(philo->right_fork);
Also used for logging and death detection.

3. Timers
Use gettimeofday() or clock_gettime() for millisecond precision.
Avoid sleep() â€” use usleep() + custom accurate sleep.

4. Synchronization
Protect shared data:
last_meal_time
someone_died
meals_eaten
Use mutexes for race-free access.

5. Logging
Use mutex around printf to avoid jumbled logs.
Example format:
[123456] 3 is eating



ğŸ›¡ï¸ Strategy Summary
âœ… Avoid Deadlock:

Use fork-pickup order (odd/even)
Limit concurrent philosophers

âœ… Prevent Starvation:

Use monitor thread
Track and update last_meal_time

âœ… Clean Architecture:

1 thread per philosopher
1 monitor thread
Mutex per fork + for printing

ğŸ“š Concept Recap
Term	Meaning
Thread	One philosopher = one thread
Mutex	Lock to prevent simultaneous resource access
Deadlock	Everyone waiting for each other forever
Starvation	Someone never gets to eat
Race condition	Conflicting thread access to shared data
Mutual exclusion	One thread at a time in critical sections
Critical section	Shared-resource code needing protection

ğŸ§  Analogy
Imagine 5 developers with one keyboard between each pair. To commit code, they need both left and right keyboards.
If everyone grabs one and waits for the other â€” deadlock.
If one is constantly skipped â€” starvation.

